import sys
import os
import shutil
import winreg
import subprocess
import time
import traceback
import threading # Added
import queue     # Added
import tkinter as tk # Added
import base64
from tkinter import ttk, messagebox, filedialog, scrolledtext, font as tkFont # Added
from typing import Optional, Tuple, Callable, Any # Added

# --- Base64 Logo ---
LOGO_BASE64 = """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"""

def get_logo_image(size: Tuple[int, int]) -> Optional[tk.PhotoImage]:
    """Create a PhotoImage from the base64 encoded app logo."""
    try:
        # Extract the actual base64 data (remove the header)
        base64_data = LOGO_BASE64.split(',')[-1]
        
        # Create a PhotoImage from the base64 data
        img = tk.PhotoImage(data=base64.b64decode(base64_data))
        
        # If a size is provided and different from original, we need to subsample
        # This is a simple approach since tkinter doesn't have great resizing
        if size:
            # Use the subsample method to get a smaller version
            # Not ideal but works for simple icons
            orig_width = img.width()
            orig_height = img.height()
            
            # Calculate subsample factors
            width_factor = max(1, int(orig_width / size[0]))
            height_factor = max(1, int(orig_height / size[1]))
            
            # Apply subsample
            img = img.subsample(width_factor, height_factor)
            
        return img
    except Exception as e:
        print(f"Error creating logo from base64: {e}", file=sys.stderr)
        return None

# --- Constants ---
APP_NAME = "ANPE"
REGISTRY_KEY_PATH = rf"Software\Microsoft\Windows\CurrentVersion\Uninstall\{APP_NAME}"
# Additional registry locations that might store ANPE-related settings
REGISTRY_SETTINGS_PATH = rf"Software\rcverse\ANPE_GUI" # Settings path used by QSettings in the app
REGISTRY_USER_PATHS = [
    REGISTRY_KEY_PATH,           # Main uninstall key
    REGISTRY_SETTINGS_PATH,      # App settings
    rf"Software\rcverse",        # Parent company key (only if empty after removing ANPE_GUI)
]
REGISTRY_INSTALL_LOCATION_VALUE = "InstallLocation"
REGISTRY_SHORTCUT_LOCATION_VALUE = "ShortcutLocation"

# UI Constants
WINDOW_WIDTH = 500     # Increased width
WINDOW_HEIGHT = 520    # Reduced height
PADDING = 15
PRIMARY_FONT_FAMILY = "Segoe UI"
FALLBACK_FONT_FAMILY = "Arial" # Use a common fallback
DEFAULT_FONT_SIZE = 10
TITLE_FONT_SIZE = 20    # Increased from 16 for more emphasis
SUBTITLE_FONT_SIZE = 11 # New constant for subtitle text
SMALL_FONT_SIZE = 9    # Added for smaller text
LOGO_SIZE = (70, 70)    # Size for the logo display (width, height)

# Colors
LIGHT_BG_COLOR = "#FFFFFF"
PRIMARY_COLOR = "#005A9C" # ANPE Blue
SECONDARY_TEXT_COLOR = "#555555"
ERROR_COLOR = "#D32F2F"
WARNING_COLOR = "#F57C00" # Orange for warnings
SUCCESS_COLOR = "#388E3C"
BORDER_COLOR = "#CCCCCC"
INFO_COLOR = "#0277BD" # Blue for information
INPUT_BG_COLOR = "#F9F9F9" # Light gray for input background
LOG_BG_COLOR_PROGRESS = "#F5F5F5" # Very light gray for progress view log
LOG_BG_COLOR_COMPLETION = "#F0F4F8" # Light blue-gray for completion view log
INPUT_HEIGHT = 26  # Standard height for input elements to match buttons

# Worker Communication Actions
ACTION_STATUS = "status"
ACTION_LOG = "log"
ACTION_PROGRESS = "progress"
ACTION_FINISHED = "finished"

# View Names (for switching)
VIEW_WELCOME = "Welcome"
VIEW_PROGRESS = "Progress"
VIEW_COMPLETION = "Completion"

# Add to constants section at the top
UNINSTALL_LOG_DIR = "logs"
UNINSTALL_LOG_FILE = "uninstall_log.txt"

# Add to constants section at the top
ANPE_INSTALLED_DIRS = [
    "anpe_gui",  # Main application code directory
    "python",    # Python environment directory
]

ANPE_INSTALLED_FILES = [
    "ANPE.exe",      # Main executable
    "uninstall.exe", # Uninstaller executable
    "LICENSE.txt",   # License file (if present)
    "README.md",     # Readme file (if present)
    "requirements.txt", # Requirements file (if present)
    "config.ini"     # Configuration file (if present)
]

# --- Helper Functions (New for Tkinter) ---
def set_widget_state(widget: ttk.Widget, state: str):
    """Safely sets the state of a widget (e.g., 'normal', 'disabled')."""
    try:
        if widget.winfo_exists():
            widget.config(state=state)
    except tk.TclError as e:
        print(f"Warning: Could not set state '{state}' for widget: {e}")

def center_window(win):
    """Centers a Tkinter window on the screen."""
    win.update_idletasks()
    width = win.winfo_width()
    height = win.winfo_height()
    x = (win.winfo_screenwidth() // 2) - (width // 2)
    y = (win.winfo_screenheight() // 2) - (height // 2)
    win.geometry(f'{width}x{height}+{x}+{y}')


# --- Uninstall Worker (Adapted for Tkinter Threading) ---
class UninstallWorker(threading.Thread):
    """Worker thread to handle the actual uninstallation process."""

    def __init__(self, install_path: str, output_queue: queue.Queue, remove_models: bool):
        super().__init__(daemon=True) # Make it a daemon thread
        if not install_path or not os.path.isdir(install_path):
            raise ValueError("Invalid installation path provided to UninstallWorker.")
        self.install_path = os.path.abspath(install_path)
        self.log_dir = os.path.join(self.install_path, "logs")
        self.log_path = os.path.join(self.log_dir, "uninstall_log.txt")
        self.uninstaller_script_path = os.path.abspath(__file__)
        self.output_queue = output_queue
        self._full_log = [] # Store the full log content
        self.remove_models = remove_models

    def _send_update(self, action: str, data: Any):
        """Send updates to the main thread via the queue."""
        try:
            self.output_queue.put((action, data))
        except Exception as e:
            # Log error if queue fails? Unlikely but possible.
            print(f"Error putting item on queue: {e}")

    def _log(self, message: str):
        """Log message to file and send update to UI."""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}"
        self._full_log.append(log_entry) # Add timestamped entry to full log

        try:
            os.makedirs(self.log_dir, exist_ok=True)
            with open(self.log_path, "a", encoding='utf-8') as f:
                f.write(log_entry + "\n")
        except OSError as e:
            print(f"Error writing to log file {self.log_path}: {e}", file=sys.stderr)
            # Send log error to UI
            self._send_update(ACTION_LOG, f"[Log Write Error] {message}")
            return # Don't emit the original message if write failed

        self._send_update(ACTION_LOG, message) # Send only the message part to UI queue

    def run(self):
        """Main uninstallation process."""
        steps = 5 if self.remove_models else 4  # Add model cleaning step if requested
        current_step = 0
        final_message = ""
        success = True

        try:
            self._log(f"Uninstaller script path: {self.uninstaller_script_path}")
            self._log(f"Target installation directory: {self.install_path}")
            self._log(f"Log file path: {self.log_path}")
            self._log(f"Model removal requested: {self.remove_models}")

            # --- Step 1: Remove Start Menu Shortcut ---
            current_step += 1
            self._send_update(ACTION_PROGRESS, (current_step, steps))
            self._send_update(ACTION_STATUS, "Removing Start Menu shortcut...")
            self._log("Attempting to remove Start Menu shortcut...")
            shortcut_removed, shortcut_msg = self._remove_shortcuts()
            self._log(shortcut_msg)
            if not shortcut_removed:
                self._log("Warning: Failed to remove Start Menu shortcut. Continuing uninstall.")

            # --- Step 2: Remove Registry Entries ---
            current_step += 1
            self._send_update(ACTION_PROGRESS, (current_step, steps))
            self._send_update(ACTION_STATUS, "Removing registry entries...")
            self._log("Attempting to remove registry entries...")
            registry_removed, registry_msg = self._remove_registry_entries()
            self._log(registry_msg)
            if not registry_removed:
                self._log("Warning: Failed to remove registry entries. Continuing uninstall.")
                
            # --- Step 3: Clean ANPE Models (if requested) ---
            if self.remove_models:
                current_step += 1
                self._send_update(ACTION_PROGRESS, (current_step, steps))
                self._send_update(ACTION_STATUS, "Cleaning ANPE models (this may take a while)...")
                self._log("Attempting to clean ANPE-related models...")
                
                models_cleaned, models_msg = self._clean_anpe_models()
                self._log(models_msg)
                if not models_cleaned:
                    self._log("Warning: Failed to completely clean ANPE models. Continuing uninstall.")

            # --- Step 4: Remove Installed Files and Directories ---
            current_step += 1
            self._send_update(ACTION_PROGRESS, (current_step, steps))
            self._send_update(ACTION_STATUS, "Removing installed files...")
            self._log(f"Attempting to remove files and directories in {self.install_path}...")
            files_removed, files_msg = self._remove_installed_files()
            self._log(files_msg)
            if not files_removed:
                success = False
                self._log("Error: Failed to remove some installed files or directories. Uninstallation incomplete.")
                # Use the summary message from _remove_installed_files if available
                if "File removal summary:" in files_msg:
                    final_message = files_msg.split("File removal summary:")[0].strip() # Get errors part
                    if not final_message: final_message = "Failed to remove some files/directories."
                else:
                     final_message = "Failed to remove some installed files/directories."

            # --- Step 5: Finalization ---
            current_step += 1
            self._send_update(ACTION_PROGRESS, (current_step, steps))
            if success:
                self._send_update(ACTION_STATUS, "Uninstallation completed successfully.")
                self._log("Uninstallation process completed successfully.")
                if not final_message: # Only set if not already set by failure
                    final_message = f"{APP_NAME} uninstalled successfully."
            else:
                self._send_update(ACTION_STATUS, "Uninstallation failed.")
                self._log("Uninstallation process failed.")
                if not final_message: # Ensure final_message is set on failure
                     final_message = "Uninstallation failed. See logs for details."

        except Exception as e:
            success = False
            error_details = traceback.format_exc()
            final_message = f"An unexpected error occurred: {e}"
            # Try sending update even in catastrophic failure
            try:
                self._send_update(ACTION_STATUS, "Uninstallation failed due to an error.")
            except Exception:
                pass # Ignore if queue fails here
            self._log(f"FATAL ERROR during uninstallation: {e}\n{error_details}")
            print(f"Uninstallation Error: {e}\n{error_details}", file=sys.stderr)

        finally:
            # Ensure the final signal is always emitted via the queue
            full_log_content = "\n".join(self._full_log)
            self._send_update(ACTION_FINISHED, (success, final_message, full_log_content, self.log_path))

    # --- Core Logic Methods (Unchanged) ---
    def _remove_shortcuts(self) -> tuple[bool, str]:
        """Removes the Start Menu shortcut using registry information."""
        shortcut_path = None
        try:
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, REGISTRY_KEY_PATH, 0, winreg.KEY_READ) as reg_key:
                try:
                    shortcut_path, _ = winreg.QueryValueEx(reg_key, REGISTRY_SHORTCUT_LOCATION_VALUE)
                except FileNotFoundError:
                    return True, f"Registry value '{REGISTRY_SHORTCUT_LOCATION_VALUE}' not found. Assuming no shortcut to remove."

            if shortcut_path and os.path.exists(shortcut_path):
                os.remove(shortcut_path)
                shortcut_dir = os.path.dirname(shortcut_path)
                try:
                    os.rmdir(shortcut_dir)
                    return True, f"Shortcut '{shortcut_path}' and parent directory '{shortcut_dir}' removed."
                except OSError:
                    return True, f"Shortcut '{shortcut_path}' removed (parent directory not empty)."
            elif shortcut_path:
                return True, f"Shortcut path '{shortcut_path}' found in registry but file does not exist."
            else:
                return True, "No shortcut path found in registry."

        except FileNotFoundError:
            return True, f"Registry key '{REGISTRY_KEY_PATH}' not found. Assuming no shortcut to remove."
        except OSError as e:
            return False, f"Error removing shortcut '{shortcut_path}': {e}"
        except Exception as e:
            return False, f"Unexpected error removing shortcut: {e}"

    def _remove_registry_entries(self) -> tuple[bool, str]:
        """Removes all application's registry keys."""
        success = True
        removed_count = 0
        errors = []
        results = []

        # We'll delete keys in order - most specific to least specific
        for reg_path in REGISTRY_USER_PATHS:
            try:
                # First check if the key exists
                try:
                    with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_READ) as key:
                        # Key exists, attempt to delete it recursively
                        self._log(f"Found registry key: {reg_path}, removing...")
                        
                        # Delete any subkeys recursively (if any)
                        self._delete_key_recursive(winreg.HKEY_CURRENT_USER, reg_path)
                        
                        removed_count += 1
                        results.append(f"Registry key '{reg_path}' removed successfully.")
                except FileNotFoundError:
                    # This key doesn't exist, which is fine
                    self._log(f"Registry key '{reg_path}' not found. Skipping.")
                    results.append(f"Registry key '{reg_path}' not found. Nothing to remove.")
                    
            except OSError as e:
                error_msg = f"Error removing registry key '{reg_path}': {e}"
                self._log(f"ERROR: {error_msg}")
                errors.append(error_msg)
                success = False
            except Exception as e:
                error_msg = f"Unexpected error removing registry key '{reg_path}': {e}"
                self._log(f"ERROR: {error_msg}")
                errors.append(error_msg)
                success = False
                
        # Generate the summary message
        if removed_count > 0:
            summary = f"Successfully removed {removed_count} registry keys."
        else:
            summary = "No registry keys were found to remove."
            
        if errors:
            summary += "\nErrors encountered:\n" + "\n".join(errors)
            
        return success, summary
        
    def _delete_key_recursive(self, root_key, sub_key):
        """
        Recursively delete a registry key and all its subkeys.
        """
        try:
            # Open the key
            with winreg.OpenKey(root_key, sub_key, 0, winreg.KEY_READ | winreg.KEY_ENUMERATE_SUB_KEYS) as key:
                # Enumerate subkeys
                subkey_count = winreg.QueryInfoKey(key)[0]
                
                # If no subkeys, we can delete directly
                if subkey_count == 0:
                    winreg.DeleteKey(root_key, sub_key)
                    return
                    
                # Otherwise, we need to collect subkey names first
                # (Can't modify while enumerating)
                subkey_names = []
                for i in range(subkey_count):
                    # Get each subkey name
                    subkey_name = winreg.EnumKey(key, i)
                    subkey_names.append(subkey_name)
                    
            # Now delete each subkey
            for subkey_name in subkey_names:
                # Full path to the subkey
                full_subkey_path = f"{sub_key}\\{subkey_name}"
                # Recursively delete this subkey
                self._delete_key_recursive(root_key, full_subkey_path)
                
            # After all subkeys are deleted, delete the main key
            winreg.DeleteKey(root_key, sub_key)
        except FileNotFoundError:
            # Key doesn't exist
            pass
        except Exception as e:
            self._log(f"Error during recursive registry key deletion: {e}")
            raise  # Re-raise to be caught by the caller

    def _remove_installed_files(self) -> tuple[bool, str]:
        """Removes only ANPE-related files and directories within the installation path."""
        removed_count = 0
        skipped_count = 0
        error_count = 0
        errors = []

        # Skip trying to remove log directory during uninstallation
        norm_log_path = os.path.normcase(self.log_path)
        norm_log_dir = os.path.normcase(self.log_dir)

        if not os.path.exists(self.install_path):
            return True, "Installation directory does not exist. Nothing to remove."

        try:
            items = os.listdir(self.install_path)
        except OSError as e:
            return False, f"Could not list installation directory '{self.install_path}': {e}"

        for item_name in items:
            item_path = os.path.join(self.install_path, item_name)
            norm_item_path = os.path.normcase(os.path.abspath(item_path))

            # Skip logs - they'll be handled by completion page
            if norm_item_path == norm_log_path or norm_item_path == norm_log_dir:
                skipped_count += 1
                continue

            # Only remove known ANPE files and directories
            is_anpe_dir = item_name in ANPE_INSTALLED_DIRS
            is_anpe_file = item_name in ANPE_INSTALLED_FILES
            
            if not (is_anpe_dir or is_anpe_file):
                self._log(f"Skipping non-ANPE item: {item_path}")
                skipped_count += 1
                continue

            try:
                if os.path.isdir(item_path):
                    self._log(f"Removing ANPE directory: {item_path}")
                    shutil.rmtree(item_path, ignore_errors=False)
                    removed_count += 1
                elif os.path.isfile(item_path):
                    # Don't remove uninstaller yet - it's still running
                    if item_name == "uninstall.exe":
                        skipped_count += 1
                        continue
                    self._log(f"Removing ANPE file: {item_path}")
                    os.remove(item_path)
                    removed_count += 1
            except (OSError, PermissionError) as e:
                error_msg = f"Failed to remove {item_path}: {e}"
                self._log(f"ERROR: {error_msg}")
                errors.append(error_msg)
                error_count += 1

        try:
            # Check if only uninstaller and logs remain
            remaining_items = [item for item in os.listdir(self.install_path) 
                             if item != "uninstall.exe" and item != "logs"]
            if not remaining_items:
                self._log("Only uninstaller and logs remain. Directory will be removed on close.")
            else:
                non_anpe_items = [item for item in remaining_items if item not in ANPE_INSTALLED_DIRS + ANPE_INSTALLED_FILES]
                if non_anpe_items:
                    self._log(f"Non-ANPE items remain in directory: {', '.join(non_anpe_items)}")
        except OSError as e:
            self._log(f"Warning: Could not check installation directory contents: {e}")

        summary = f"File removal summary: {removed_count} removed, {skipped_count} skipped, {error_count} errors."
        if errors:
            summary += "\nErrors encountered:\n" + "\n".join(errors)

        return error_count == 0, summary

    def _clean_anpe_models(self) -> tuple[bool, str]:
        """Cleans ANPE-related models (spaCy and benepar) using the ANPE CLI command."""
        try:
            # Find the Python executable in the installation directory
            python_dir = os.path.join(self.install_path, "python")
            if not os.path.exists(python_dir):
                return False, "Python directory not found in the installation path."
                
            # Look for the ANPE CLI in the Scripts directory
            scripts_dir = os.path.join(python_dir, "Scripts")
            anpe_cli = os.path.join(scripts_dir, "anpe.exe") 
            
            # If Scripts directory or anpe.exe doesn't exist, try direct module execution
            if not os.path.exists(scripts_dir) or not os.path.exists(anpe_cli):
                self._log("ANPE CLI executable not found in Scripts directory. Trying Python module approach...")
                
                # Find Python executable
                python_exe = None
                for executable_name in ["python.exe", "pythonw.exe"]:
                    executable_path = os.path.join(python_dir, executable_name)
                    if os.path.exists(executable_path):
                        python_exe = executable_path
                        break
                        
                # Also check the Scripts directory for Python
                if not python_exe and os.path.exists(scripts_dir):
                    for executable_name in ["python.exe", "pythonw.exe"]:
                        executable_path = os.path.join(scripts_dir, executable_name)
                        if os.path.exists(executable_path):
                            python_exe = executable_path
                            break
                
                if not python_exe:
                    return False, "Python executable not found in the installation directory."
                    
                self._log(f"Found Python executable: {python_exe}")
                
                # Use Python to run the module directly
                self._log("Starting ANPE model cleanup using Python module...")
                command = [python_exe, "-m", "anpe.utils.clean_models", "--force"]
            else:
                # Use the ANPE CLI directly
                self._log(f"Found ANPE CLI at: {anpe_cli}")
                self._log("Starting ANPE model cleanup using CLI...")
                command = [anpe_cli, "setup", "--clean-models"]
            
            # Execute the command
            self._send_update(ACTION_STATUS, "Cleaning ANPE models (this may take a while)...")
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW,
                shell=False,
                encoding='utf-8',
                errors='replace'
            )
            
            # Process the output
            output_lines = []
            found_start = False  # Track whether we've found the command start
            cleaning_in_progress = False  # Track when actual cleaning is happening
            
            while True:
                line = process.stdout.readline()
                if not line and process.poll() is not None:
                    break
                    
                if line:
                    clean_line = line.strip()
                    if clean_line:  # Skip empty lines
                        output_lines.append(clean_line)
                        
                        # Update status based on key phrases
                        if "Starting" in clean_line or "Cleanup" in clean_line:
                            found_start = True
                            
                        if "Found" in clean_line and "package" in clean_line:
                            cleaning_in_progress = True
                            # Update UI status with what's being cleaned
                            model_info = clean_line.split("Found")[1].strip() if "Found" in clean_line else "models"
                            self._send_update(ACTION_STATUS, f"Cleaning ANPE models: {model_info}...")
                            
                        if "Removing" in clean_line:
                            cleaning_in_progress = True
                            # Extract what's being removed for status update
                            model_info = clean_line.split("Removing")[1].strip() if "Removing" in clean_line else "models"
                            self._send_update(ACTION_STATUS, f"Removing model: {model_info}...")
                            
                        # Log the output
                        self._log(f"Model cleanup: {clean_line}")
            
            # Wait for the process to complete
            return_code = process.wait()
            
            # If no start messages were found, the command might have failed silently
            if not found_start and len(output_lines) < 2:
                return False, "ANPE model cleanup command didn't produce expected output. It may not have executed properly."
                
            if return_code == 0:
                if not cleaning_in_progress and len(output_lines) < 3:
                    # No models needed cleaning - this is a success case
                    return True, "ANPE model cleanup completed - no models needed to be removed."
                else:
                    return True, "ANPE model cleanup completed successfully."
            else:
                return False, f"ANPE model cleanup failed with return code {return_code}. See log for details."
                
        except Exception as e:
            error_details = traceback.format_exc()
            error_message = f"Error during model cleanup: {e}\n{error_details}"
            self._log(error_message)
            return False, f"Failed to clean ANPE models: {e}"

# --- Main Application Window (Tkinter) ---
class UninstallMainWindow(tk.Tk):
    """Main Tkinter application window."""
    def __init__(self):
        super().__init__()
        self._worker_thread: Optional[UninstallWorker] = None
        self._output_queue = queue.Queue()
        self._is_running = False
        self._install_path: Optional[str] = None # Added to store install path
        self._remove_models: bool = True  # Default value, will be updated

        self._setup_window()
        self._setup_styles()
        self._create_widgets()
        self._check_queue() # Start polling the queue

    def _setup_window(self):
        self.title(f"{APP_NAME} Uninstaller")
        self.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}")
        self.resizable(False, False)
        center_window(self)
        # Use custom close handler
        self.protocol("WM_DELETE_WINDOW", self._on_close)

    def _setup_styles(self):
        self.style = ttk.Style(self)
        try:
            self.style.theme_use('vista')
        except tk.TclError:
            print("Warning: 'vista' theme not available. Using default.", file=sys.stderr)
        try:
            self.default_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=DEFAULT_FONT_SIZE)
            self.title_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
        except tk.TclError:
            print(f"Warning: Font '{PRIMARY_FONT_FAMILY}' not found. Using '{FALLBACK_FONT_FAMILY}'.", file=sys.stderr)
            self.default_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=DEFAULT_FONT_SIZE)
            self.title_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
        self.style.configure('.', font=self.default_font, background=LIGHT_BG_COLOR)
        self.style.configure("TFrame", background=LIGHT_BG_COLOR)
        self.style.configure("TLabel", background=LIGHT_BG_COLOR, foreground="#333333", padding=0)
        self.style.configure("Title.TLabel", font=self.title_font, foreground=PRIMARY_COLOR, padding=(0, PADDING // 2))
        self.style.configure("Subtitle.TLabel", font=self.subtitle_font, foreground=SECONDARY_TEXT_COLOR, padding=(0, PADDING // 4))
        self.style.configure("Secondary.TLabel", foreground=SECONDARY_TEXT_COLOR)
        self.style.configure("Error.TLabel", foreground=ERROR_COLOR)
        self.style.configure("Warning.TLabel", foreground=WARNING_COLOR)
        self.style.configure("Success.TLabel", foreground=SUCCESS_COLOR)
        self.style.configure("Info.TLabel", foreground=INFO_COLOR)
        self.style.configure("TLabelframe", background=LIGHT_BG_COLOR)
        self.style.configure("TLabelframe.Label", background=LIGHT_BG_COLOR, font=self.default_font)
        self.style.configure("TProgressbar", thickness=20, background=BORDER_COLOR, troughcolor=LIGHT_BG_COLOR)
        self.style.configure("TButton", font=self.default_font, padding=(PADDING, PADDING // 2))
        self.style.configure("PathBrowse.TButton", padding=(10, 4))  # Adjusted padding for height
        self.style.configure("PathLabel.TLabel", 
                           font=(PRIMARY_FONT_FAMILY, SMALL_FONT_SIZE, "italic"),
                           foreground=SECONDARY_TEXT_COLOR,
                           background=LIGHT_BG_COLOR)

    def _create_widgets(self):
        """Create and layout the main container and frames."""
        self.main_container = ttk.Frame(self, padding=0, style="TFrame")
        self.main_container.pack(expand=True, fill="both")
        self.main_container.grid_rowconfigure(0, weight=1)
        self.main_container.grid_columnconfigure(0, weight=1)
        self.frames = {}
        for F, name in [(WelcomeFrame, VIEW_WELCOME),
                        (ProgressFrame, VIEW_PROGRESS),
                        (CompletionFrame, VIEW_COMPLETION)]:
            if name == VIEW_WELCOME:
                frame = F(self.main_container, start_uninstall_callback=self._start_uninstall, style="TFrame")
            elif name == VIEW_COMPLETION:
                frame = F(self.main_container, close_callback=self._on_close, style="TFrame")
            else:
                frame = F(self.main_container, style="TFrame")
            self.frames[name] = frame
            frame.grid(row=0, column=0, sticky="nsew")
        self._switch_view(VIEW_WELCOME)

    def _switch_view(self, view_name: str):
        """Bring the specified view frame to the top."""
        frame = self.frames.get(view_name)
        if frame:
            frame.tkraise()
        else:
            print(f"Error: View '{view_name}' not found.", file=sys.stderr)

    def _start_uninstall(self, install_path: str, remove_models: bool = True):
        """Initiate the uninstallation process in a worker thread."""
        if self._is_running:
            messagebox.showwarning("In Progress", "Uninstallation is already running.")
            return

        try:
            # Ensure progress frame exists before trying to reset
            progress_frame = self.frames.get(VIEW_PROGRESS)
            if not progress_frame:
                raise RuntimeError("Progress frame not found during uninstall start.")

            self._worker_thread = UninstallWorker(install_path, self._output_queue, remove_models)
            self._is_running = True
            self._install_path = install_path # Store the install path
            self._remove_models = remove_models  # Store for potential future use
            progress_frame.reset_progress() # Reset UI before switching
            self._switch_view(VIEW_PROGRESS)
            self._worker_thread.start()

        except ValueError as e: # Catch specific error from worker init
            messagebox.showerror("Error", f"Failed to start uninstaller: {e}")
            self._is_running = False # Ensure state is reset
        except Exception as e:
            messagebox.showerror("Unexpected Error", f"An unexpected error occurred while starting the uninstallation: {e}")
            traceback.print_exc() # Log detailed error
            self._is_running = False

    def _check_queue(self):
        """Periodically check the queue for updates from the worker."""
        try:
            while True: # Process all messages currently in queue
                action, data = self._output_queue.get_nowait()
                self._process_worker_update(action, data)
        except queue.Empty:
            pass # No messages currently
        except Exception as e:
            # Log unexpected error during queue processing
            print(f"Error processing worker queue: {e}")
            traceback.print_exc()
        finally:
            # Schedule the next check, always
            self.after(100, self._check_queue)

    def _process_worker_update(self, action: str, data: Any):
        """Process a message received from the worker thread."""
        progress_frame = self.frames.get(VIEW_PROGRESS)
        completion_frame = self.frames.get(VIEW_COMPLETION)

        # Ensure frames exist before updating them
        if not progress_frame or not completion_frame:
            print("Error: UI frames not ready to process worker update.", file=sys.stderr)
            return

        try:
            if action == ACTION_STATUS:
                progress_frame.set_status(data)
            elif action == ACTION_LOG:
                progress_frame.append_log(data)
            elif action == ACTION_PROGRESS:
                current, total = data
                progress_frame.set_progress(current, total)
            elif action == ACTION_FINISHED:
                self._is_running = False # Mark process as finished
                success, message, full_log, log_path = data
                completion_frame.set_state(success, message, full_log, log_path)
                self._switch_view(VIEW_COMPLETION)
            else:
                print(f"Warning: Unknown action from worker: {action}", file=sys.stderr)
        except tk.TclError as e:
            # Catch errors if widgets are destroyed during update (e.g., rapid close)
            print(f"Tkinter error processing worker update ({action}): {e}")
        except Exception as e:
            # Catch any other unexpected errors during UI update
            print(f"Error processing worker update ({action}): {e}")
            traceback.print_exc()

    def _on_close(self):
        """Handle window close event (WM_DELETE_WINDOW)."""
        if self._is_running:
            if messagebox.askyesno("Confirm Exit",
                                   "Uninstallation is in progress. Are you sure you want to exit?\n" + \
                                   "This may leave the uninstallation incomplete.",
                                   default=messagebox.NO):
                # Worker is daemon, will exit when main thread exits.
                # No explicit termination needed/safe.
                self.destroy()
            # else: User selected No, do nothing
        else:
            # Not running, attempt self-destruction before closing
            if self._install_path:
                try:
                    uninstaller_exe_path = os.path.join(self._install_path, "uninstall.exe")
                    install_dir_path = self._install_path

                    if os.path.exists(uninstaller_exe_path):
                        print(f"Attempting self-destruction for: {uninstaller_exe_path} and {install_dir_path}")
                        # Use cmd.exe to wait, delete self, then remove directory
                        # timeout /t 2: Wait 2 seconds
                        # /nobreak: Ignore key presses during timeout
                        # > nul: Suppress timeout output
                        # &&: Run next command only if previous succeeds
                        # del /f /q "...": Force quiet deletion of the uninstaller
                        # rmdir /s /q "...": Quietly remove the directory and its contents
                        cmd = f'cmd.exe /c "timeout /t 2 /nobreak > nul && del /f /q "{uninstaller_exe_path}" && rmdir /s /q "{install_dir_path}""'
                        
                        # DETACHED_PROCESS allows the parent (uninstaller) to exit immediately
                        # CREATE_NO_WINDOW hides the command prompt window
                        creation_flags = subprocess.DETACHED_PROCESS | subprocess.CREATE_NO_WINDOW
                        subprocess.Popen(cmd, creationflags=creation_flags, shell=False)
                        print("Self-destruction process launched.")
                    else:
                         print("Uninstaller executable not found, skipping self-destruction.")
                except Exception as e:
                    print(f"Error launching self-destruction process: {e}")
                    # Log error, but proceed with closing

            # Not running, close immediately
            self.destroy()


# --- Tkinter UI Frames (New) ---
class WelcomeFrame(ttk.Frame):
    """Welcome screen frame."""
    def __init__(self, parent, start_uninstall_callback: Callable[[str, bool], None], **kwargs):
        super().__init__(parent, **kwargs)
        self.start_uninstall_callback = start_uninstall_callback
        self.install_path: Optional[str] = None
        self.manual_path_selected = False
        self.path_status_text = ""
        self.path_status_style = "Secondary.TLabel"
        self.remove_models_var = tk.BooleanVar(value=True)  # Default to True (checked)

        self._setup_styles()  # Set up styles FIRST
        self._setup_ui()      # Then set up UI components
        self.update_install_path() # Initial check

    def _setup_styles(self):
        self.style = ttk.Style(self)
        try:
            self.style.theme_use('vista')
        except tk.TclError:
            print("Warning: 'vista' theme not available. Using default.", file=sys.stderr)
        try:
            self.default_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=DEFAULT_FONT_SIZE)
            self.title_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
            self.status_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=SUBTITLE_FONT_SIZE-1, slant="italic")
        except tk.TclError:
            print(f"Warning: Font '{PRIMARY_FONT_FAMILY}' not found. Using '{FALLBACK_FONT_FAMILY}'.", file=sys.stderr)
            self.default_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=DEFAULT_FONT_SIZE)
            self.title_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
            self.status_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=SUBTITLE_FONT_SIZE-1, slant="italic")

        self.style.configure('.', font=self.default_font, background=LIGHT_BG_COLOR)
        self.style.configure("TFrame", background=LIGHT_BG_COLOR)
        self.style.configure("TLabel", background=LIGHT_BG_COLOR, foreground="#333333", padding=0)
        self.style.configure("Title.TLabel", font=self.title_font, foreground=PRIMARY_COLOR, padding=(0, PADDING // 2))
        self.style.configure("Subtitle.TLabel", font=self.subtitle_font, foreground=SECONDARY_TEXT_COLOR, padding=(0, PADDING // 4))
        self.style.configure("Status.TLabel", font=self.status_font, foreground=SECONDARY_TEXT_COLOR)
        self.style.configure("Secondary.TLabel", foreground=SECONDARY_TEXT_COLOR)
        self.style.configure("Error.TLabel", foreground=ERROR_COLOR)
        self.style.configure("Warning.TLabel", foreground=WARNING_COLOR)
        self.style.configure("Success.TLabel", foreground=SUCCESS_COLOR)
        self.style.configure("Info.TLabel", foreground=INFO_COLOR)
        self.style.configure("TLabelframe", background=LIGHT_BG_COLOR)
        self.style.configure("TLabelframe.Label", background=LIGHT_BG_COLOR, font=self.default_font)
        self.style.configure("TProgressbar", thickness=20, background=BORDER_COLOR, troughcolor=LIGHT_BG_COLOR)
        self.style.configure("TButton", font=self.default_font, padding=(PADDING, PADDING // 2))

    def _setup_ui(self):
        self.columnconfigure(0, weight=1)
        
        # Center container frame
        center_container = ttk.Frame(self, style="TFrame")
        center_container.grid(row=0, column=0, sticky="nsew")
        center_container.columnconfigure(0, weight=1)
        
        # Spacer at top (pushes content down slightly)
        ttk.Frame(center_container, style="TFrame").grid(row=0, column=0, pady=PADDING)

        # Logo Frame
        logo_frame = ttk.Frame(center_container, style="TFrame")
        logo_frame.grid(row=1, column=0, pady=(0, PADDING//2))
        
        # Logo Label (centered)
        self.logo_label = ttk.Label(logo_frame, style="TLabel")
        self.logo_image = get_logo_image(LOGO_SIZE)
        if self.logo_image:
            self.logo_label.config(image=self.logo_image)
            self.logo_label.image = self.logo_image
        self.logo_label.pack(anchor="center")

        # Title (centered)
        title_label = ttk.Label(
            center_container,
            text=f"{APP_NAME} Uninstaller",
            style="Title.TLabel",
            anchor="center"
        )
        title_label.grid(row=2, column=0, pady=(0, PADDING))

        # Welcome Text (centered)
        welcome_text = ttk.Label(
            center_container,
            text=(f"This will uninstall {APP_NAME} and its components from your computer. "
                  f"The uninstaller will remove {APP_NAME} application files and registry entries, "
                  f"but will not affect other Python installations or your personal files."),
            style="Subtitle.TLabel",
            wraplength=WINDOW_WIDTH - 8 * PADDING,  # Adjusted wrapping
            anchor="center",
            justify="center"
        )
        welcome_text.grid(row=3, column=0, pady=(0, PADDING * 2), padx=PADDING * 2)
        welcome_text.configure(font=(PRIMARY_FONT_FAMILY, SMALL_FONT_SIZE))  # Made even smaller

        # Path Section Frame - Make it full width
        path_section = ttk.Frame(center_container, style="TFrame")
        path_section.grid(row=4, column=0, pady=(0, PADDING), padx=PADDING * 2, sticky="ew")
        path_section.columnconfigure(0, weight=1)  # Make the frame expand horizontally

        # Path Label (left aligned, italic, smaller)
        path_label = ttk.Label(
            path_section,
            text="Uninstall ANPE from:",
            style="PathLabel.TLabel",
            anchor="w"
        )
        path_label.grid(row=0, column=0, columnspan=2, sticky="w", pady=(0, 5))

        # Path Entry and Browse Button Frame
        path_entry_frame = ttk.Frame(path_section, style="TFrame")
        path_entry_frame.grid(row=1, column=0, sticky="ew")
        path_entry_frame.columnconfigure(0, weight=1)  # Make entry expand
        path_entry_frame.columnconfigure(1, weight=0)  # Don't expand browse button

        # Configure entry style for consistent height
        entry_height = 26  # Match button height
        entry_pady = (entry_height - DEFAULT_FONT_SIZE - 6) // 2  # Calculate padding to center text

        # Path Entry with fixed height through padding
        self.path_entry = ttk.Entry(  # Changed to ttk.Entry for consistent styling
            path_entry_frame,
            font=(PRIMARY_FONT_FAMILY, DEFAULT_FONT_SIZE),
            style="Path.TEntry"  # Use custom style
        )
        self.path_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))

        # Configure style for the entry
        self.style.configure("Path.TEntry",
            padding=(5, entry_pady),  # Horizontal and vertical padding
            selectbackground=PRIMARY_COLOR,
            fieldbackground=INPUT_BG_COLOR
        )

        # Browse Button with matching height and fixed width
        self.browse_button = ttk.Button(
            path_entry_frame,
            text="Browse...",
            command=self._browse_for_path,
            width=12,  # Fixed width in characters
            style="PathBrowse.TButton"
        )
        self.browse_button.grid(row=0, column=1, sticky="e")  # Changed column to 1

        # Path Status Label (centered, italic)
        self.path_status_label = ttk.Label(
            path_section,
            text="",
            style="Status.TLabel",
            anchor="center"
        )
        self.path_status_label.grid(row=2, column=0, sticky="ew", pady=(5, 0))

        # Add checkbox for model removal
        model_cleanup_frame = ttk.Frame(center_container, style="TFrame")
        model_cleanup_frame.grid(row=5, column=0, pady=(0, PADDING), padx=PADDING * 2, sticky="ew")

        # Model cleanup checkbox
        self.remove_models_checkbox = ttk.Checkbutton(
            model_cleanup_frame,
            text="Remove ANPE-related models (spaCy and benepar models)",
            variable=self.remove_models_var,
            style="TCheckbutton"
        )
        self.remove_models_checkbox.grid(row=0, column=0, sticky="w")

        # Bottom Button Frame (centered)
        button_frame = ttk.Frame(center_container, style="TFrame")
        button_frame.grid(row=6, column=0, pady=PADDING * 2, sticky="ew")
        button_frame.columnconfigure(0, weight=1)  # Enable centering

        # Uninstall button with fixed width
        self.uninstall_button = ttk.Button(
            button_frame,
            text="Uninstall",
            command=self._on_uninstall_click,
            width=15  # Fixed width for better appearance
        )
        self.uninstall_button.grid(row=0, column=0)  # Use grid instead of pack
        set_widget_state(self.uninstall_button, "disabled")  # Disabled initially

    def _get_install_path_from_registry(self) -> Optional[str]:
        """Get the installation path from the registry."""
        try:
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, REGISTRY_KEY_PATH, 0, winreg.KEY_READ) as reg_key:
                install_path, _ = winreg.QueryValueEx(reg_key, REGISTRY_INSTALL_LOCATION_VALUE)
            if install_path and os.path.isdir(install_path):
                return os.path.normpath(install_path)
            else:
                print(f"Registry path found but invalid: {install_path}", file=sys.stderr)
                return None
        except FileNotFoundError:
            # This is expected if the app isn't installed, don't spam console
            # print(f"Registry key '{REGISTRY_KEY_PATH}' not found.", file=sys.stderr)
            return None
        except Exception as e:
            print(f"Error reading registry: {e}", file=sys.stderr)
            return None

    def update_install_path(self, manual_path: Optional[str] = None):
        """Check registry or use manual path, then update UI."""
        path_to_use = manual_path if manual_path else self._get_install_path_from_registry()

        if path_to_use:
            self.install_path = path_to_use
            self.manual_path_selected = bool(manual_path)
            
            # Update path entry with detected path and make it read-only
            self.path_entry.delete(0, tk.END)
            self.path_entry.insert(0, self.install_path)
            
            # Make the entry read-only (state=readonly doesn't work well with styling)
            # Instead, bind events to prevent modification
            self.path_entry.bind("<Key>", lambda e: "break" if e.keysym not in ("c", "C") or not (e.state & 4) else None)  # Allow Ctrl+C
            
            # Update status label based on source and validation
            if self.manual_path_selected:
                is_likely_anpe, _ = self._is_likely_anpe_installation(path_to_use)
                if is_likely_anpe:
                    self.path_status_text = "✓ Manually selected - Appears to be an ANPE installation"
                    self.path_status_style = "Success.TLabel"
                else:
                    self.path_status_text = "⚠ Manually selected - Unlikely to be an ANPE installation"
                    self.path_status_style = "Warning.TLabel"
            else:
                self.path_status_text = "✓ Automatically detected from registry"
                self.path_status_style = "Info.TLabel"
                
            self.path_status_label.config(text=self.path_status_text, style=self.path_status_style)
            set_widget_state(self.uninstall_button, "normal")
        else:
            self.install_path = None
            self.manual_path_selected = False
            
            # Clear entry and make it writable
            self.path_entry.delete(0, tk.END)
            self.path_entry.unbind("<Key>")  # Allow typing for manual path entry
            
            # Update status label
            self.path_status_text = "Installation path not found. Use 'Browse...' to select it manually."
            self.path_status_style = "Error.TLabel"
            self.path_status_label.config(text=self.path_status_text, style=self.path_status_style)
            set_widget_state(self.uninstall_button, "disabled")

    def _browse_for_path(self):
        """Open directory dialog for manual path selection."""
        try:
            initial_dir = self.path_entry.get().strip() or os.path.expanduser("~")
        except:
            initial_dir = os.path.expanduser("~")
            
        selected_path = filedialog.askdirectory(title=f"Select {APP_NAME} Installation Directory", initialdir=initial_dir)
        if selected_path and os.path.isdir(selected_path):
            # Update the UI with the manually selected path
            self.update_install_path(manual_path=os.path.normpath(selected_path))
        elif selected_path:
            messagebox.showerror("Invalid Selection", f"The selected path is not a valid directory:\n{selected_path}")
            # If the browse resulted in an error, revert state (re-check registry)
            self.update_install_path()
        # If dialog cancelled, do nothing, keep previous state.

    def _is_likely_anpe_installation(self, path: str) -> tuple[bool, list]:
        """
        Check if the given path appears to be an ANPE installation.
        Returns a tuple of (is_likely_anpe, file_list)
        """
        if not os.path.isdir(path):
            return (False, [])
            
        expected_anpe_files = [
            "ANPE.exe", 
            "uninstall.exe"
        ]
        expected_anpe_dirs = [
            "anpe_gui",
            "python"
        ]
        
        items = []
        try:
            items = os.listdir(path)
        except (PermissionError, OSError):
            # If we can't access the directory, we can't tell
            return (False, [])
            
        # Check for key ANPE files/directories
        anpe_indicators_found = 0
        for item in expected_anpe_files:
            if item in items and os.path.isfile(os.path.join(path, item)):
                anpe_indicators_found += 1
                
        for item in expected_anpe_dirs:
            if item in items and os.path.isdir(os.path.join(path, item)):
                anpe_indicators_found += 1
                
        # If we found at least 2 indicators, it's likely an ANPE installation
        # Return both the result and the file list for showing the user
        return (anpe_indicators_found >= 2, items)

    def _on_uninstall_click(self):
        """Handle uninstall button click, confirming if path was manual."""
        if not self.install_path:
            # Try to get path from entry if install_path is not set
            entered_path = self.path_entry.get().strip()
            if entered_path and os.path.isdir(entered_path):
                self.install_path = entered_path
                self.manual_path_selected = True
            else:
                messagebox.showerror("Error", "No valid installation path specified.")
                return

        # First level check - is it manually selected?
        if self.manual_path_selected:
            # Additional safety check for manually selected paths
            is_anpe, file_list = self._is_likely_anpe_installation(self.install_path)
            
            if not is_anpe:
                # Format file list for display, limit to reasonable length
                formatted_files = "\n".join(file_list[:15])
                if len(file_list) > 15:
                    formatted_files += f"\n... and {len(file_list) - 15} more files/folders"
                
                unsafe_message = (
                    f"⚠️ WARNING: The directory you selected does NOT appear to be an ANPE installation!\n\n"
                    f"Path: {self.install_path}\n\n"
                    f"Directory contents:\n{formatted_files}\n\n"
                    f"Continuing with uninstallation may DELETE DATA UNRELATED TO ANPE.\n\n"
                    f"Are you ABSOLUTELY SURE you want to delete these files?"
                )
                
                proceed = messagebox.askyesno(
                    "⚠️ DANGEROUS OPERATION", 
                    unsafe_message,
                    default=messagebox.NO, 
                    icon=messagebox.WARNING
                )
                
                if not proceed:
                    return
                    
            # Normal manual path warning (shown even if it looks like ANPE)
            confirm_msg = f"WARNING: You manually selected the installation path:\n{self.install_path}\n\nUninstalling from the wrong directory can damage other applications or your system.\n\nARE YOU ABSOLUTELY SURE you want to proceed?"
            confirm_title = "Confirm Manual Path Uninstall"
            
            proceed = messagebox.askyesno(confirm_title, confirm_msg, default=messagebox.NO, icon=messagebox.WARNING)
            
            if not proceed:
                return
        else:
            # Standard confirmation for registry-detected paths
            confirm_msg = f"Are you sure you want to uninstall {APP_NAME} from:\n{self.install_path}?\n\nThis action cannot be undone."
            confirm_title = "Confirm Uninstall"
            
            proceed = messagebox.askyesno(confirm_title, confirm_msg, default=messagebox.NO, icon=messagebox.QUESTION)
            
            if not proceed:
                return

        self.start_uninstall_callback(self.install_path, self.remove_models_var.get())

    def _load_logo_image(self, size: Tuple[int, int]) -> Optional[tk.PhotoImage]:
        """Load the logo image using the base64 encoded data."""
        return get_logo_image(size)


class ProgressFrame(ttk.Frame):
    """Progress display frame."""
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self._setup_styles()  # Set up styles before UI
        self._setup_ui()
        
    def _setup_styles(self):
        try:
            self.title_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
        except tk.TclError:
            self.title_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
        
        style = ttk.Style(self)
        style.configure("Title.TLabel", font=self.title_font, foreground=PRIMARY_COLOR, padding=(0, PADDING // 2))
        style.configure("Subtitle.TLabel", font=self.subtitle_font, foreground=SECONDARY_TEXT_COLOR, padding=(0, PADDING // 4))

    def _setup_ui(self):
        self.columnconfigure(0, weight=1)

        # --- Header with Logo and Title (mimicking PyQt views) ---
        header_frame = ttk.Frame(self, style="TFrame")
        header_frame.grid(row=0, column=0, pady=(PADDING, PADDING // 2), padx=PADDING, sticky="ew")
        header_frame.columnconfigure(1, weight=1)  # Title column expands
        
        # Logo display (left side of header)
        self.logo_label = ttk.Label(header_frame, style="TLabel")
        self.logo_image = self._load_logo_image(LOGO_SIZE)
        if self.logo_image:
            self.logo_label.config(image=self.logo_image)
            self.logo_label.image = self.logo_image  # Keep reference
        self.logo_label.grid(row=0, column=0, padx=(0, PADDING), sticky="w")
        
        # Title in header (right side of logo)
        self.title_label = ttk.Label(
            header_frame, 
            text=f"Uninstalling {APP_NAME}...", 
            style="Title.TLabel", 
            anchor="w"
        )
        self.title_label.grid(row=0, column=1, sticky="w")

        # Status Label (as subtitle)
        self.status_label = ttk.Label(self, text="Initializing...", style="Subtitle.TLabel", anchor="w", justify="left")
        self.status_label.grid(row=1, column=0, pady=(0, PADDING // 2), padx=PADDING, sticky="w")

        # Progress Bar
        self.progress_bar = ttk.Progressbar(self, orient="horizontal", mode="determinate", length=WINDOW_WIDTH - 2 * PADDING)
        self.progress_bar.grid(row=2, column=0, pady=PADDING // 2, padx=PADDING, sticky="ew")

        # Log Area (ScrolledText)
        self.log_text = scrolledtext.ScrolledText(
            self, 
            height=10, 
            wrap=tk.WORD, 
            state="disabled", 
            relief="solid", 
            bd=1, 
            bg=LOG_BG_COLOR_PROGRESS,
            font=(PRIMARY_FONT_FAMILY, DEFAULT_FONT_SIZE -1)
        ) # Slightly smaller font for logs
        self.log_text.grid(row=3, column=0, pady=(PADDING // 2, PADDING), padx=PADDING, sticky="nsew")
        self.rowconfigure(3, weight=1) # Allow log area to expand vertically

        # Configure styles for log text tags
        self.log_text.tag_config("ERROR", foreground=ERROR_COLOR)
        self.log_text.tag_config("WARNING", foreground="#FFA000") # Orange-like
        self.log_text.tag_config("INFO", foreground=SECONDARY_TEXT_COLOR)
        self.log_text.tag_config("DEBUG", foreground="#888888")

    def reset_progress(self):
        """Reset progress bar and log."""
        self.set_status("Initializing...")
        self.set_progress(0, 1) # Initial state
        set_widget_state(self.log_text, "normal")
        self.log_text.delete("1.0", tk.END)
        set_widget_state(self.log_text, "disabled")

    def set_status(self, status: str):
        """Update the status label text."""
        if self.winfo_exists():
            self.status_label.config(text=status)

    def set_progress(self, current_step: int, total_steps: int):
        """Update the progress bar value."""
        if self.winfo_exists():
            if total_steps > 0:
                percentage = (current_step / total_steps) * 100
                self.progress_bar['value'] = percentage
            else:
                self.progress_bar['value'] = 0

    def append_log(self, message: str):
        """Append a message to the log area, applying tags."""
        if not self.winfo_exists(): return

        set_widget_state(self.log_text, "normal")
        tag = "INFO"
        if message.startswith("ERROR") or message.startswith("[Log Write Error]"):
            tag = "ERROR"
        elif message.startswith("WARNING"):
            tag = "WARNING"
        elif message.startswith("DEBUG"):
             tag = "DEBUG"
        # Add more conditions for other log levels if needed

        self.log_text.insert(tk.END, message + "\n", tag)
        self.log_text.see(tk.END) # Auto-scroll
        set_widget_state(self.log_text, "disabled")

    def _load_logo_image(self, size: Tuple[int, int]) -> Optional[tk.PhotoImage]:
        """Load the logo image using the base64 encoded data."""
        return get_logo_image(size)


class CompletionFrame(ttk.Frame):
    """Completion screen frame."""
    def __init__(self, parent, close_callback: Callable[[], None], **kwargs):
        super().__init__(parent, **kwargs)
        self.close_callback = close_callback
        self._full_log_content: Optional[str] = None
        self._log_path: Optional[str] = None  # Add this to store log path
        self._setup_styles()
        self._setup_ui()

    def _setup_styles(self):
        try:
            self.title_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=PRIMARY_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
        except tk.TclError:
            self.title_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=TITLE_FONT_SIZE, weight="bold")
            self.subtitle_font = tkFont.Font(family=FALLBACK_FONT_FAMILY, size=SUBTITLE_FONT_SIZE)
        
        style = ttk.Style(self)
        style.configure("Title.TLabel", font=self.title_font, foreground=PRIMARY_COLOR, padding=(0, PADDING // 2))
        style.configure("Success.Title.TLabel", font=self.title_font, foreground=SUCCESS_COLOR, padding=(0, PADDING // 2))
        style.configure("Error.Title.TLabel", font=self.title_font, foreground=ERROR_COLOR, padding=(0, PADDING // 2))
        style.configure("Subtitle.TLabel", font=self.subtitle_font, foreground=SECONDARY_TEXT_COLOR, padding=(0, PADDING // 4))

    def _setup_ui(self):
        # Configure grid weights to make content expand but keep bottom fixed
        self.columnconfigure(0, weight=1)
        
        # Create main content frame that will expand
        main_content = ttk.Frame(self, style="TFrame")
        main_content.grid(row=0, column=0, sticky="nsew")
        main_content.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)  # Allow main content to expand

        # --- Header with Logo and Title ---
        header_frame = ttk.Frame(main_content, style="TFrame")
        header_frame.grid(row=0, column=0, pady=(PADDING, PADDING // 2), padx=PADDING, sticky="ew")
        header_frame.columnconfigure(1, weight=1)
        
        # Logo display
        self.logo_label = ttk.Label(header_frame, style="TLabel")
        self.logo_image = self._load_logo_image(LOGO_SIZE)
        if self.logo_image:
            self.logo_label.config(image=self.logo_image)
            self.logo_label.image = self.logo_image
        self.logo_label.grid(row=0, column=0, padx=(0, PADDING), sticky="w")
        
        # Title
        self.title_label = ttk.Label(header_frame, text="Uninstallation Complete", style="Title.TLabel", anchor="w")
        self.title_label.grid(row=0, column=1, sticky="w")

        # Message Label
        self.message_label = ttk.Label(main_content, text="", style="Subtitle.TLabel", 
                                     wraplength=WINDOW_WIDTH - 4 * PADDING, anchor="w", justify="left")
        self.message_label.grid(row=1, column=0, pady=(0, PADDING // 2), padx=PADDING, sticky="w")

        # Details button frame
        details_button_frame = ttk.Frame(main_content, style="TFrame")
        details_button_frame.grid(row=2, column=0, pady=(0, PADDING // 2), padx=PADDING, sticky="w")

        self.details_button = ttk.Button(details_button_frame, text="Show Details", command=self._toggle_details)
        self.details_button.grid(row=0, column=0)
        set_widget_state(self.details_button, "disabled")

        # Log Area (ScrolledText, initially not gridded)
        self.log_text = scrolledtext.ScrolledText(
            main_content, 
            height=12,
            wrap=tk.WORD, 
            state="disabled",
            relief="solid",
            bd=1,
            bg=LOG_BG_COLOR_COMPLETION,
            font=(PRIMARY_FONT_FAMILY, DEFAULT_FONT_SIZE - 1)
        )

        # Bottom section frame - no separator, just padding
        bottom_frame = ttk.Frame(self, style="TFrame")
        bottom_frame.grid(row=1, column=0, sticky="sew", pady=(PADDING, 0))
        bottom_frame.columnconfigure(0, weight=1)
        self.rowconfigure(1, weight=0)  # Don't allow bottom frame to expand

        # Controls container with padding
        controls_frame = ttk.Frame(bottom_frame, style="TFrame")
        controls_frame.grid(row=0, column=0, padx=PADDING, pady=(0, PADDING), sticky="sw")
        
        # Checkbox
        self.keep_logs_var = tk.BooleanVar(value=True)
        self.keep_logs_checkbox = ttk.Checkbutton(
            controls_frame,
            text="Keep uninstallation log file",
            variable=self.keep_logs_var,
            style="TCheckbutton"
        )
        self.keep_logs_checkbox.grid(row=0, column=0, sticky="w", pady=(0, PADDING//2))
        
        # Close Button
        self.close_button = ttk.Button(controls_frame, text="Close", command=self._on_close)
        self.close_button.grid(row=1, column=0, sticky="w")

    def _toggle_details(self):
        """Show or hide the detailed log."""
        if self.log_text.winfo_ismapped(): # Check if gridded (visible)
            self._hide_details()
        else:
            self._show_details()

    def _show_details(self):
        """Show the detailed log."""
        if not self._full_log_content or not self.winfo_exists():
            return
        # Place the log text widget above the bottom frame
        self.log_text.grid(row=3, column=0, pady=(0, PADDING//2), padx=PADDING, sticky="nsew")
        self.rowconfigure(3, weight=1)
        set_widget_state(self.log_text, "normal")
        self.log_text.delete("1.0", tk.END)
        self.log_text.insert(tk.END, self._full_log_content)
        set_widget_state(self.log_text, "disabled")
        self.details_button.config(text="Hide Details")
        self.update_idletasks()

    def _hide_details(self):
        """Hide the detailed log."""
        if not self.winfo_exists():
            return
        self.log_text.grid_forget()
        self.rowconfigure(3, weight=0)
        self.details_button.config(text="Show Details")
        self.update_idletasks()

    def _on_close(self):
        """Handle close button click with log retention logic."""
        if not self.keep_logs_var.get() and self._log_path:
            try:
                # Get log directory path before closing streams
                log_dir = os.path.dirname(self._log_path)
                log_path = self._log_path

                # Only close streams if we're running with pythonw.exe
                if "pythonw.exe" in sys.executable.lower():
                    # Safely close streams if they're file objects
                    if hasattr(sys, 'stdout') and hasattr(sys.stdout, 'close') and not sys.stdout.closed:
                        try:
                            sys.stdout.close()
                        except:
                            pass
                    if hasattr(sys, 'stderr') and hasattr(sys.stderr, 'close') and not sys.stderr.closed:
                        try:
                            sys.stderr.close()
                        except:
                            pass

                # Use delayed deletion command for logs
                cmd = f'cmd.exe /c "timeout /t 1 /nobreak > nul && del /f /q "{log_path}" && rmdir /q "{log_dir}""'
                creation_flags = subprocess.DETACHED_PROCESS | subprocess.CREATE_NO_WINDOW
                subprocess.Popen(cmd, creationflags=creation_flags, shell=False)
            except Exception as e:
                # Don't try to print here as streams might be closed
                pass

        # Call the original close callback
        self.close_callback()

    def set_state(self, success: bool, final_message: str, full_log: str, log_path: Optional[str] = None):
        """Set the final state of the completion screen."""
        if not self.winfo_exists():
            return

        self._full_log_content = full_log
        self._log_path = log_path  # Store the log path

        if success:
            self.title_label.config(text="Uninstallation Complete", style="Success.Title.TLabel")
            self.message_label.config(text=f"{APP_NAME} has been successfully uninstalled.")
        else:
            self.title_label.config(text="Uninstallation Failed", style="Error.Title.TLabel")
            error_text = f"An error occurred during uninstallation."
            # Use the final_message from worker if available and specific
            if final_message and "unexpected error occurred" not in final_message.lower():
                 error_text += f"\n\nDetails: {final_message}"
            elif final_message:
                 # Generic error message if worker had unexpected exception
                 error_text += " Please check the logs for more details."

            self.message_label.config(text=error_text)

        # Enable the details button only if there's log content
        if self._full_log_content:
            set_widget_state(self.details_button, "normal")
        else:
            set_widget_state(self.details_button, "disabled")

        # Ensure log is hidden initially
        self._hide_details()

    def _load_logo_image(self, size: Tuple[int, int]) -> Optional[tk.PhotoImage]:
        """Load the logo image using the base64 encoded data."""
        return get_logo_image(size)


# --- Tkinter main ---
def main():
    """Main entry point for the uninstaller GUI."""
    # Only redirect stdout/stderr if running with pythonw.exe
    original_stdout = sys.stdout
    original_stderr = sys.stderr
    log_file = None

    try:
        if "pythonw.exe" in sys.executable.lower():
            log_dir_fallback = os.path.join(os.path.expanduser("~"), "AppData", "Local", APP_NAME, "Logs")
            os.makedirs(log_dir_fallback, exist_ok=True)
            log_file = open(os.path.join(log_dir_fallback, "uninstaller_gui_errors.log"), "a", encoding='utf-8')
            sys.stdout = log_file
            sys.stderr = log_file
            print(f"--- {APP_NAME} Uninstaller GUI Started ({time.strftime('%Y-%m-%d %H:%M:%S')}) ---")

        try:
            app = UninstallMainWindow()
            app.mainloop()
        except Exception as e:
            print("--- Uninstaller GUI FATAL ERROR ---")
            traceback.print_exc()
            try:
                import ctypes
                ctypes.windll.user32.MessageBoxW(0, 
                    f"A critical error occurred in the uninstaller GUI: {e}\nSee logs for details.", 
                    f"{APP_NAME} Uninstaller Error", 
                    0x10 | 0x0)
            except Exception:
                pass
    finally:
        # Restore original streams before exiting
        if "pythonw.exe" in sys.executable.lower():
            sys.stdout = original_stdout
            sys.stderr = original_stderr
            if log_file:
                try:
                    log_file.close()
                except:
                    pass

if __name__ == "__main__":
    main() 